import random
import numpy as np
import pandas as pd

# Implement Rposenbrock function
def fitness_f1(individuals):
    return sum(100.0*(individuals[1:]-individuals[:-1]**2.0)**2.0 + (1-individuals[:-1])**2.0)

# Implement Griewanks function
def fitness_f2(individuals):
    sum = 0
    prod = 1
    for i in range(len(individuals)):
        sum += individuals[i]**2/4000
        prod *= np.cos(individuals[i]/np.sqrt(i+1))
    return sum - prod + 1

def objective_function(individuals, objective_no=1):
    #return [fitness_f1(individuals) , fitness_f2(individuals)]
    return fitness_f1(individuals) if objective_no == 1 else fitness_f2(individuals)

def generate_seed(runs, increment=50):
    base_seed = random.randint(5, 10000)  # Generate a random base seed
    seed_values = [base_seed + i * increment for i in range(runs)]
    return seed_values


def recombination(parents):
    """
    Perform Intermediate Global Crossover to generate an offspring from multiple parents.

    This function takes a list of parent vectors and generates an offspring by 
    combining the parents' genes using randomly generated weights. The weights 
    are normalized to ensure they sum to 1, and the offspring is a weighted 
    average of the parents.

    Parameters:
    parents (list of numpy.ndarray): A list of parent vectors. Each parent is 
                                     represented as a numpy array of the same 
                                     dimensions.

    Returns:
    numpy.ndarray: The offspring vector generated by combining the parents' genes.
    """
    num_parents = len(parents)
    dimensions = len(parents[0])
    
    # Generate random weights for each parent
    weights = np.random.uniform(0, 1, num_parents)
    weights /= np.sum(weights)  # Normalize weights to sum to 1
    
    # Initialize Child
    child = np.zeros(dimensions)
    
    # Combine parents' genes using the weights
    for i in range(num_parents):
        child += weights[i] * parents[i]
    
    return child

def tournament_selection(population, fitness, tournament_size):
    """
    Perform tournament selection to choose a parent from the population.

    Parameters:
    population (list of numpy.ndarray): The population of individuals.
    fitness (list of float): The fitness values of the individuals in the population.
    tournament_size (int): The number of individuals to be selected for the tournament.

    Returns:
    numpy.ndarray: The selected parent individual.
    """
    selected_indices = np.random.choice(len(population), tournament_size, replace=False)
    selected_fitness = [fitness[i] for i in selected_indices]
    best_index = selected_indices[np.argmin(selected_fitness)]
    return population[best_index], best_index

def enviromental_selection(population, offspring, offspring_fitness, variances):
    """
    Perform environmental selection to choose the best individuals from the offspring.

    Parameters:
    population (list of numpy.ndarray): The population of individuals.
    offspring (list of numpy.ndarray): The offspring generated from the population.
    fitness (list of float): The fitness values of the individuals in the population.
    offspring_fitness (list of float): The fitness values of the offspring individuals.
    variances (list of float): The variances of the individuals in the population.

    Returns:
    list of numpy.ndarray: The selected individuals from the offspring.
    list of float: The variances of the selected individuals.
    """
    # Combine the offspring and their fitness
    combined_offspring = offspring
    combined_fitness = offspring_fitness
    
    # Sort the combined offspring based on fitness
    sorted_indices = np.argsort(combined_fitness)
    sorted_offspring = [combined_offspring[i] for i in sorted_indices]
    sorted_fitness = [combined_fitness[i] for i in sorted_indices]
    
    # Select the best individuals from the combined offspring
    selected_population = sorted_offspring[:len(population)]
    selected_variances = [variances[i] for i in sorted_indices[:len(population)]]
    
    return selected_population, selected_variances

def EP_process(generations, bound, parameters):
    # Extract parameters
    population_size = parameters[0]
    generations = parameters[1]
    dim = parameters[2]

    # Create the initial particle and variance of the population
    solution_vector = np.random.uniform(low=bound[0], high=bound[1], size=(population_size, dim))
    variancevector = np.var(solution_vector, axis=0)

    for generation in generations:
            print(f'Generation: {generation} of {generations} ...')
            
            # Evaluate the fitness of each dimention in the population
            """
                FITNESS FUNCTION
                    - Fitness function is used to evaluate the fitness of the population.
                    - Store the fitness value of the offsprings into a new variable
            """
            #fitness = [objective_function(solution) for solution in solution_vector]
            
            
            """
                MUTATION 
                    - Mutation Type (crunchy function) 
                    - Mutation function is used to create new offsprings from the current population
                    - Store the new offsprings into a new variable
            """
            #offspring_vector = [mutation(solution, variancevector) for solution in solution_vector]
            """
                FITNESS FUNCTION
                    - Fitness function is used to evaluate the fitness of the offsprings
                    - Store the fitness value of the offsprings into a new variable
            """
            #pffspring_fitness = [objective_function(offspring) for offspring in offspring_vector]
            """
                COMBINANTION OF POPULATION AND OFFSPRING
                    - Combine the population and the offsprings
            """
            """
                SELECTION FUNCTION
                    - Selection function is used to select the best individuals from the population and the offspring population
                    - Store the selected individuals into a new variable
                    - Store variance of the selected individuals into a new variable.
            """
            #selected_individuals = selection(fitness, pffspring_fitness, solution_vector, offspring_vector, variancevector)
            """
                UPDATE POPULATION
                    - Update the population with the selected individuals
            """
            # Update the population and variance of the population
            #solution_vector = selected_individuals

            # Track the best solution: store the best solution and variance of the best solution
            #best_solution = np.min(fitness)
            #best_variances = np.min(variancevector)

def ES_process(bound, parameters, seed_value, objective_no):
    # Extract parameters
    generations = parameters[0]
    dim = parameters[1]
    μ = parameters[2]   # number of parent
    λ = parameters[3]   # number of offspring
    random.seed(seed_value)

    # Create the initial particle and variance of the population
    particles = np.random.uniform(low=bound[0], high=bound[1], size=(μ, dim))
    variances = [[4.0] * dim for _ in range(μ)]

    T = (np.sqrt(2 * np.sqrt(dim))) ** -1
    T_ = (np.sqrt(2 * dim)) ** -1

    for generation in range(generations):
        # evaluate the fitness of the population
        fitness = [objective_function(particle,objective_no) for particle in particles]
        
        offspring_population = []
        pffspring_variance = []
        # iterate over offspring
        for i in range(λ):
            # randomly select two parents, obtain variance of selected parents
            # create a function to apply Tournament selection to select parents
            parent1, parent1_idx = tournament_selection(particles, fitness, 2)
            parent2, parent2_idx = tournament_selection(particles, fitness, 2)
            parents = [parent1, parent2]

            parents_variance = [variances[parent1_idx], variances[parent2_idx]]
            
            # recmbine the parents and its variance by applying the recombination function
            child = recombination(parents)
            #child_variance = recombination(parents_variance)
            child_variance = [p1 + p2 / 2 for p1,p2 in zip(parents_variance[0], parents_variance[1])]

            # generate scaling factor p0 and p1 
            p0 = np.random.normal(0, T) # single value drawn from a normal distribution
            p1 = np.random.normal(0, T_, dim) # vector drawn from a normal distribution

            # mutate variance of the child
            child_variance_mut = child_variance * np.exp(p0 + p1)
            # calculate sigma diag matrix
            sigma = np.diag(child_variance_mut)
            # Extract diagonal elements from sigma
            sigma_diag = np.diag(sigma)     
            # afterward, mutate child
            offspring = child + np.random.normal(0, sigma_diag, size=dim)
            pffspring_variance.append(child_variance_mut)
            offspring_population.append(offspring)
        
        # evaluate the fitness of the offspring
        offspring_fitness = [objective_function(inidividual, objective_no) for inidividual in offspring_population]
        # select the best individuals from the population and the offspring population
        selected_individuals = enviromental_selection(particles, offspring_population, offspring_fitness, pffspring_variance)

        # update the population and variance with the selected individuals
        particles = selected_individuals[0]
        variances = selected_individuals[1]
            
def main():
    # General Parameters 
    population_size = 50   
    generations = 100 
    objective = 2   # Number of Objective function to optimize

    # Solution Boundary 
    bound = [-30, 30]   # Lower bound and Upper bound of the search space
    runs = 30   
    dim = [20, 50]   # Dimension of the problem
    seed_value = generate_seed(runs, increment=10)

    for obj in range(objective):
        print(f"Run: {run+1} Dimension: {dim_} Objective: {obj+1}")

        for run in range(runs):
            # Loop through the dimension, 20 and 50
            for dim_ in dim:
                print(f"Run: {run+1} Dimension: {dim_}")
 
                # EP optimization process
                #EP_parameters = [generations, population_size]
                #EP_process(bound, EP_parameters, seed_value[run])

                # ES optimization process
                μ = 10  # Parents
                λ = 20  # Offspring
                ES_parameters = [generations, dim_, μ, λ]
                ES_process(bound, ES_parameters, seed_value[run], obj)
            
            # Save the result into list or dataframe
            





if __name__ == "__main__":
    main()